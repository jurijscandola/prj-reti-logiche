
# Logic Networks Project (Progetto di Reti Logiche)

**Authors:** Daniel Shala (ID: 10710181) & Jurij Diego Scandola (ID: 10709931)
**Academic Year:** 2022/2023
**Professor:** Gianluca Palermo

---

## 1. Introduction

This project involves the **implementation of a hardware module described in VHDL**. The primary goal of this module is to **interface with an external memory**.

At a high level of abstraction, the system receives a serial input signal (`i_w`). The initial two bits of this signal indicate one of four output channels of a multiplexer. The remaining bits of `i_w` specify a memory block address from which data will be extracted and displayed on the designated output channel.

## 2. General Specifications & Interface

The component interacts through a specific set of input and output signals:

### Input Signals
*   **`i_start`**: A serial input signal generated by the Test Bench, indicating the start of a transmission. It remains high (1) for a minimum of 2 and a maximum of 18 clock cycles.
*   **`i_w`**: The serial input signal containing the data to be processed, generated by the Test Bench. Its length varies from a minimum of two bits to a maximum of eighteen bits.
*   **`i_clk`**: The clock signal, generated by the Test Bench.
*   **`i_rst`**: The reset signal, used to initialize the machine to an IDLE state, ready for the first `i_start` signal. A reset (RESET=1) is guaranteed before the first `START` (START=1).

### Output Signals
*   **`o_z0`, `o_z1`, `o_z2`, `o_z3`**: The four output channels of the multiplexer. These are 8-bit channels. They are initialized to 0 and remain unchanged except for the channel receiving the message read from memory.
*   **`o_done`**: An output signal that communicates the completion of processing. It goes high (1) for exactly one clock cycle when the output data is visible on the selected channel, then returns to 0. When `o_done` is 0, all channels must be zero.
*   **`o_mem_addr`**: A 16-bit output vector sent to the memory, containing the address from which to read data.
*   **`o_mem_en`**: An ENABLE signal to be sent to the memory for communication (both read and write).
*   **`o_mem_we`**: The WRITE ENABLE signal for memory. It must be 0 for reading from memory.

### Memory Description
The output data is stored in a memory instantiated within the testbench. Memory cells have **16-bit addresses** and contain **8-bit encoded data**. The component requests data from the memory cell whose address is constructed from the `i_w` signal.

**`i_w` Signal Processing:**
*   The first two bits of `i_w` are saved into a vector (`selected_out`) to identify one of the four output channels.
*   The subsequent `n` bits (where `n` is between 0 and 16) are concatenated into a second 16-bit vector (`mem_reg`), initialized to zero, which represents the memory address.
*   Sign extension is performed on the most significant bit if `i_w` transmits fewer than eighteen bits in total.

## 3. Design Overview

The module's operation is managed by a **Finite State Automaton (FSA)**, which proved to be more advantageous than an initial counter-based approach due to better information gathering and avoiding issues like lost bits during transitions.

The FSA is composed of **8 distinct states**:

*   **`IDLE`**: The initial state, where the component awaits the `i_start` signal to go high (1). The first bit of `i_w` is saved in this state. A `RESET` signal will return the machine to this state.
*   **`HEADER`**: In this state, the second bit transmitted by `i_w` is saved.
*   **`GET ADDRESS`**: This is a recursive state, acting like a `while` loop that continues as long as `i_start` is high. At each iteration, a bit from `i_w` is concatenated to a 15-bit vector (effectively shifting bits left). When `i_start` goes low (0), the resulting vector is saved as the memory input address, `o_mem_en` is set to 1 to allow memory reading, and the state changes.
*   **`WAIT RAM`**: The machine enters this state to await a response from the memory.
*   **`GET DATA`**: Upon receiving data from the memory, this state uses the first two bits of `i_w` (the `selected_out` vector) to determine which multiplexer output channel (`Z0`, `Z1`, `Z2`, `Z3`) will be used. The value returned by memory is then saved to the identified channel.
*   **`WAIT DATA`**: An engineered "buffer" state, lasting for one clock cycle. This state was introduced to better manage potential signal delays and ensure data realignment.
*   **`WRITE OUT`**: In this state, memory control variables are reset to their initial values, and the previously saved values of the multiplexer outputs are rewritten. The machine then transitions to the final state.
*   **`DONE`**: The `o_done` bit is reset to 0, temporary variables and registers used in the previous state are cleared, and the machine is reset to the `IDLE` state.

### Design Choices & Optimizations
The initial design with a single state and a counter for `i_w` handling caused issues like lost bits and incorrect memory access. The final design adopted a **division into states** for better information collection. Rigorous attention was paid to VIVADO warnings, particularly "inferring latch for variable" (error 8-327), leading to efforts to **limit the number of latches/registers** to resolve simulation errors. The use of **"buffer" states like `WAIT DATA`** successfully resolved timing issues.

The number of states is considered **optimal, though not minimal**, to prevent signal transmission delays. The computational performance is satisfactory, with the output becoming available within a few clock cycles, well within the specified limit of 20 cycles.

## 4. Test Results

To verify the correct functioning of the synthesized component, analyses were performed using both an example test bench and 7 additional tests. The component **
